---
layout: post
tags: ["Swift"]
title: "Attributes in Swift"
author: Jordan Morgan
description: "Attributes can keep code clean and conscise without much effort. Today, let's cover some common, and uncommon, use cases."
image: /assets/images/logo.png
---
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift + Attributes</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift + Attributes</h1>
</header>
<section data-field="subtitle" class="p-summary">
Or, â€œOh, Those @ Thingysâ€
</section>
<section data-field="body" class="e-content">
<section name="01b1" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--outsetColumn"><figure name="4622" id="4622" class="graf graf--figure graf--layoutOutsetCenter graf--leading"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 667px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="1*OlfwF9y6uGvrywGgsAic_Q.jpeg" data-width="2100" data-height="1400" src="https://cdn-images-1.medium.com/max/1000/1*OlfwF9y6uGvrywGgsAic_Q.jpeg"></div><figcaption class="imageCaption">For some reason <a href="https://medium.com/the-traveled-ios-developers-guide/swift-keywords-v-3-0-1-f59783bf26c#.7a4h5wgcs" data-href="https://medium.com/the-traveled-ios-developers-guide/swift-keywords-v-3-0-1-f59783bf26c#.7a4h5wgcs" class="markup--anchor markup--figure-anchor" target="_blank">Iâ€™m still stuck on the MacBook + Paper</a>Â combo.</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="640e" id="640e" class="graf graf--h3 graf-after--figure graf--title">Swift + Attributes</h3><h4 name="19cc" id="19cc" class="graf graf--h4 graf-after--h3 graf--trailing graf--subtitle">Or, â€œOh, Those @Â Thingysâ€</h4></div></div></section><section name="e14f" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="da0d" id="da0d" class="graf graf--p graf--leading graf--trailing"><a href="https://www.buddybuild.com/blog/optimizing-your-swift-codebase-with-attributes" data-href="https://www.buddybuild.com/blog/optimizing-your-swift-codebase-with-attributes" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This weekâ€™s post is sponsored by BuddyBuildâ€Šâ€”â€Šread the post over on their blog as well.</a></p></div></div></section><section name="5298" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8586" id="8586" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf--leading"><span class="graf-dropCap">I</span> think weâ€™ve all been there. Weâ€™ve just picked up programming, or we start learning a new language where things are foreign to usâ€Šâ€”â€Šand we happen across some code. We may not understand it, but we think it works. So, we just take it in good faith and continue on, none the wiser.</p><p name="76cd" id="76cd" class="graf graf--p graf-after--p">This used to be my approach when incorporating Swiftâ€™s attributes into my own work. <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html" data-href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Swift supports a robust variety of attributes,</a> and when browsing Github reposâ€Šâ€”â€Šwe may happen across one or two we donâ€™t recognize. If youâ€™re like me, you might jot it down to Google and then be on our way.</p><p name="bed3" id="bed3" class="graf graf--p graf-after--p">No more! This week, we take a peek under the curtain at what attributes are, what they do and some fun ones to know about ğŸ’«. Lets.begin()</p><h4 name="351b" id="351b" class="graf graf--h4 graf-after--p">Why use Swiftâ€™s attributes?</h4><p name="e92a" id="e92a" class="graf graf--p graf-after--h4">Attributes help developers improve the efficiency of their codebase, without sacrificing the quality of their code. It makes for code thatâ€™s easier to read, ultimately easier to maintain and hopefully safer to use.</p><p name="8e06" id="8e06" class="graf graf--p graf-after--p">I like to think that efficiency is always at the forefront of my development. And reallyâ€Šâ€”â€Šthatâ€™s what a lot of these attributes can bring to the table, some good olâ€™ fashioned efficiency.</p><h4 name="28f6" id="28f6" class="graf graf--h4 graf-after--p">Groundwork</h4><p name="662c" id="662c" class="graf graf--p graf-after--h4">At the expense of starting by providing a boilerplate definition, letâ€™s start by providing a boilerplate definition ğŸ¤“.</p><p name="55b0" id="55b0" class="graf graf--p graf-after--p">I think itâ€™s requisite to quickly hit on what exactly an attribute is. And really, all a Swift attribute is/does is provide more information about a either type or declaration. This information can dictate everything from compiler warnings to how something is handled in memory.</p><p name="92e1" id="92e1" class="graf graf--p graf-after--p">No matter the flavor, each one is preceded by an â€œ@â€ symbol. In addition, declaration attributes may also accept arguments inside of enclosing parentheses.</p><p name="8b2a" id="8b2a" class="graf graf--p graf-after--p">So, put simply:</p><pre name="7056" id="7056" class="graf graf--pre graf-after--p">@attributeName</pre><pre name="477b" id="477b" class="graf graf--pre graf-after--pre">//Or with argumentsâ€¦<br>@attributeName(arguments)</pre><p name="2629" id="2629" class="graf graf--p graf-after--pre">Letâ€™s look at some examples from the front lines.</p><h4 name="5464" id="5464" class="graf graf--h4 graf-after--p">@available(args)</h4><p name="64a1" id="64a1" class="graf graf--p graf-after--h4">If there was a Swiss Army Knife version of a Swift attribute, it would be @available(). Flexible as it is powerful, you may find it indispensable if your daily duties revolve around managing or releasing an API. With it, one can indicate API naming changes, platform availability and more.</p><p name="d9de" id="d9de" class="graf graf--p graf-after--p">Consider an object from a metaphorical API that serves up blog posts:</p><pre name="b9b2" id="b9b2" class="graf graf--pre graf-after--p">class BasicPost {}</pre><p name="3325" id="3325" class="graf graf--p graf-after--pre">Consumers of our API have long enjoyed using the BasicPost class, though imagine weâ€™ve fielded several requests for a more honed in object that represents a technical blog post, much like the one youâ€™re reading now. So for version 1.2, we introduce it:</p><pre name="a3aa" id="a3aa" class="graf graf--pre graf-after--p">class TechnicalPost {}</pre><p name="4f6a" id="4f6a" class="graf graf--p graf-after--pre">Now, to make our documentation complete, our code sensible and our API consumers informed we could take advantage of @available() to make its presence known:</p><pre name="55dd" id="55dd" class="graf graf--pre graf-after--p">@available(*, introduced: 1.2)<br>class TechnicalPost {}</pre><p name="7377" id="7377" class="graf graf--p graf-after--pre">Now, consumers can be quickly informed about the TechnicalPost objectâ€™s introduction and availability. This particular attribute can accept several arguments, but the first one always indicates the intended platforms. The remaining arguments supported can be supplied in any order.</p><p name="149b" id="149b" class="graf graf--p graf-after--p">It can also take advantage of a wildcard. In this case, the wildcard is the asterisk youâ€™re seeing as the first argumentâ€Šâ€”â€Šwhich communicates that on all platforms the API is used on, this class was first introduced on version 1.2 (represented by the second argument).</p><p name="8b68" id="8b68" class="graf graf--p graf-after--p">Thatâ€™s neat, but also extremely broad. Thankfully, we can focus it in even more with a shorthand syntax:</p><pre name="d5e8" id="d5e8" class="graf graf--pre graf-after--p">@available(iOS 10.0, macOS 10.12)<br>class TechnicalPost {}</pre><p name="161f" id="161f" class="graf graf--p graf-after--pre">Much better! If Iâ€™m new to our fictional API, I can clearly see when this class can be used even if I donâ€™t know much about the attribute itself.</p><p name="7d18" id="7d18" class="graf graf--p graf-after--p">But, if left as is, youâ€™ll also receive a compile time error. Why ğŸ¤”?</p><p name="8b90" id="8b90" class="graf graf--p graf-after--p">Because of Appleâ€™s knack for introducing new platforms, weâ€™ve got to enforce our code to account for thatâ€Šâ€”â€Šand so we include the wildcard as the last argument to signify that this code is available for the provided platforms, and any potential future platforms.</p><p name="6ca7" id="6ca7" class="graf graf--p graf-after--p">So if Apple makes the IoT connected Apple Toaster<strong class="markup--strong markup--p-strong">Â©</strong>â€Šâ€”â€Šyouâ€™re all set:</p><pre name="39a2" id="39a2" class="graf graf--pre graf-after--p">@available(iOS 10.0, macOS 10.12, *)<br>class TechnicalPost {}</pre><p name="be48" id="be48" class="graf graf--p graf-after--pre">Now our code is already set for the next big thing that needs a splash of Appleâ€™s operating systems ğŸ‰. For the here and the now though, Apple has provided us with an enumeration representing each platform as they exist today:</p><ul class="postList"><li name="a277" id="a277" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">iOS</code></li><li name="107d" id="107d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">iOSApplicationExtension</code></li><li name="d9d1" id="d9d1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">macOS</code></li><li name="0857" id="0857" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">macOSApplicationExtension</code></li><li name="8fe2" id="8fe2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">watchOS</code></li><li name="ab30" id="ab30" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">watchOSApplicationExtension</code></li><li name="2a8a" id="2a8a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tvOS</code></li><li name="c174" id="c174" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tvOSApplicationExtension</code></li></ul><p name="beec" id="beec" class="graf graf--p graf-after--li">Before we move on from this one letâ€™s consider another commonality. With our recent changes, our API has taken off, and iOS developers the world over have entrusted us with serving them up with lovely bits of JSON that represent technical blog posts.</p><p name="1356" id="1356" class="graf graf--p graf-after--p">As such, weâ€™ve no need for the original class anymore. I think itâ€™s time we deprecate it:</p><pre name="8e2c" id="8e2c" class="graf graf--pre graf-after--p">@available(*, deprecated: 1.3)<br>class BasicPost {}</pre><p name="5ba8" id="5ba8" class="graf graf--p graf-after--pre">Now it becomes clear how useful the wildcard argument can be, as in one (ahem) <em class="markup--em markup--p-em">swift</em> move weâ€™ve deprecated BasicPost on all platforms.</p><p name="76a4" id="76a4" class="graf graf--p graf-after--p">Further, if we wanted to keep it around but a bit refactored, we couldâ€™ve even provided notice of an API naming change. Courtesy of a technique I caught from Apple, we could pair it with an unavailable argument and a typealias to make things even easier on consumers:</p><pre name="4fed" id="4fed" class="graf graf--pre graf-after--p">//From an earlier API version<br>class BasicPost {}</pre><pre name="0308" id="0308" class="graf graf--pre graf-after--pre">//From a new API version, where we renamed it for whatever reason<br>class BaseTechnicalPost {}</pre><pre name="9eb3" id="9eb3" class="graf graf--pre graf-after--pre">@available(*, unavailable, renamed: â€œBaseTechnicalPostâ€)<br>typealias BasicPost = BaseTechnicalPost</pre><p name="800c" id="800c" class="graf graf--p graf-after--pre">I personally love this, because for my moneyâ€Šâ€”â€Šthe obvious code is always the best code.</p><p name="682b" id="682b" class="graf graf--p graf-after--p">This attribute has even more tricks, with support for arguments specifying some code completely obsolete, a message to provide in conjunction with a warning or error and more.</p><h4 name="1da6" id="1da6" class="graf graf--h4 graf-after--p">@discardableResult</h4><p name="7337" id="7337" class="graf graf--p graf-after--h4">If youâ€™ve worked in a mature, legacy codebase it should come as no surprise that some functions do a bit too much.</p><p name="e3ed" id="e3ed" class="graf graf--p graf-after--p">Perhaps there is that one function hanging around thatâ€™s been added to and manipulated since the early 90s, and due to no fault of its ownâ€Šâ€”â€Šit might do 124 important things that need to happen when the software starts (access a database, setup a cache, initialize some sign in processâ€Šâ€”â€Šthe scenarios are endless).</p><p name="d952" id="d952" class="graf graf--p graf-after--p">And so times go on, because someday, youâ€™ll convince the product manager to let you come back and refactor it.</p><p name="5689" id="5689" class="graf graf--p graf-after--p">Right ğŸ˜„. <em class="markup--em markup--p-em">Right ğŸ˜…!?</em> Right ğŸ˜:</p><pre name="8c95" id="8c95" class="graf graf--pre graf-after--p">let someUnusedVarBecauseIHaveToCallThisOldInsaneFunction = anOldInsaneFunction()</pre><p name="8200" id="8200" class="graf graf--p graf-after--pre">Be that as it may, clang will pour salt on the wound here because even though weâ€™ve got to invoke this function for some outlandish coupling reasonâ€Šâ€”â€Šwe now have an unused variable to show for it as well. Talk about getting kicked while youâ€™re down ğŸ™ƒ.</p><p name="8e48" id="8e48" class="graf graf--p graf-after--p">This is where the @discardableResult attribute can help, as it tells the compiler that the result of the function may be unneeded. It also kills the warning at compile time:</p><pre name="6a1a" id="6a1a" class="graf graf--pre graf-after--p">@discardableResult func anOldInsaneFunction() -&gt; String<br>{<br>    //Bunch of business logic occurs<br>    return â€œâ€<br>}</pre><p name="926b" id="926b" class="graf graf--p graf-after--pre">Now, the code above which invokes the said function will stay there only as a relic of your past software engineering mistakesâ€Šâ€”â€Šbut it will do so without providing an error. Baby steps!</p><p name="26af" id="26af" class="graf graf--p graf-after--p">For a little syntactical sugar, at least in my opinion, one could make the state of affairs even more obvious by simply assigning to a _Â :</p><pre name="610e" id="610e" class="graf graf--pre graf-after--p">_ = anOldInsaneFunction()</pre><p name="00a4" id="00a4" class="graf graf--p graf-after--pre">Lookâ€Šâ€”â€Šit is what it is. Sometimes, there are functions or architecture in software development we canâ€™t directly control or fix, and this attribute makes that situation a little bit better.</p><h4 name="2fc3" id="2fc3" class="graf graf--h4 graf-after--p">@autoclosure</h4><p name="ea38" id="ea38" class="graf graf--p graf-after--h4">Letâ€™s bring things home with another nifty attribute that can add a little syntactical sugar. The @autoclosure attribute can allow one to automatically wrap a closure thatâ€™s supplied as an argument. As the closure doesnâ€™t take any arguments itself, itâ€™ll return the actual value of the expression thatâ€™s wrapped within it.</p><p name="f044" id="f044" class="graf graf--p graf-after--p">It sounds a little weird, but itâ€™s easily understood when you come across one. All weâ€™re really talking about here is the ability to get an expression to automatically become a closure. If youâ€™ve spent some time adding unit tests to your project, youâ€™ve likely come across this attribute several times already.</p><p name="c01d" id="c01d" class="graf graf--p graf-after--p">Assume weâ€™d like to write a simple test for a class like so:</p><pre name="f4c9" id="f4c9" class="graf graf--pre graf-after--p">class Programmer<br>{<br>    var pay:Int<br>    <br>    init(withPay pay:Int)<br>    {<br>        self.pay = pay<br>    }</pre><pre name="d653" id="d653" class="graf graf--pre graf-after--pre">    func applyRaise(by amount:Int)<br>    {<br>        self.pay += amount<br>    }<br>}</pre><pre name="f9fc" id="f9fc" class="graf graf--pre graf-after--pre">class ProgrammerTests: XCTestCase<br>{<br>    func testPayRaise()<br>    {<br>        let devsPay = 50000<br>        let raiseAmount = 25000<br>        let expectedSalaryPostRaise = devsPay + raiseAmount</pre><pre name="974b" id="974b" class="graf graf--pre graf-after--pre">        let aDev = Programmer(withPay: devsPay)<br>        aDev.applyRaise(by: raiseAmount)</pre><pre name="d855" id="d855" class="graf graf--pre graf-after--pre">        XCTAssertEqual(expectedSalaryPostRaise, aDev.pay, &quot;Unexpected salary after raise was applied.&quot;)<br>     }<br>}</pre><p name="9e72" id="9e72" class="graf graf--p graf-after--pre">The first two parameters of the XCAssertEqual are both closures that take in a generic expression. While the functionâ€™s signature can look a little intimidating, take note of the first two parameters that are taking advantage of @autoclosure:</p><pre name="35e3" id="35e3" class="graf graf--pre graf-after--p">func XCTAssertEqual&lt;T&gt;(_ expression1: @autoclosure () throws -&gt; T?, _ expression2: @autoclosure () throws -&gt; T?, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) where T : Equatable</pre><p name="f341" id="f341" class="graf graf--p graf-after--pre">Since the @autoclosure attribute is supplied, invoking the function is quite readable and trivial to write. We can either pass the closure with something as simple as a value (as we did in our previous example) or with a bit more logic, and each one is syntactically sensible:</p><pre name="558d" id="558d" class="graf graf--pre graf-after--p">class ProgrammerTests: XCTestCase<br>{<br>    func testPayRaise()<br>    {<br>        let devsPay = 50000<br>        let raiseAmount = 25000</pre><pre name="b2c9" id="b2c9" class="graf graf--pre graf-after--pre">        let aDev = Programmer(withPay: devsPay)<br>        aDev.applyRaise(by: raiseAmount)</pre><pre name="79d1" id="79d1" class="graf graf--pre graf-after--pre">        XCTAssertEqual(aDev.pay + raiseAmount, 750000, &quot;Unexpected salary after raise was applied.&quot;)<br>    }<br>}</pre><p name="b372" id="b372" class="graf graf--p graf-after--pre">Take note that when the first argument is supplied, it reads much more like an addition operation than it does a closure:</p><pre name="9548" id="9548" class="graf graf--pre graf-after--p">XCTAssertEqual(aDev.pay + raiseAmount, 750000, &quot;Unexpected salary after raise was applied.&quot;)</pre><p name="61c7" id="61c7" class="graf graf--p graf-after--pre">â€¦versus what it might look like without the @autoclosure attribute:</p><pre name="9a95" id="9a95" class="graf graf--pre graf-after--p">XCTAssertEqual({<br>    return aDev.pay + raiseAmount,<br>}, {<br>    return 75000<br>}, &quot;Unexpected salary after raise was applied.&quot;)</pre><p name="b1fb" id="b1fb" class="graf graf--p graf-after--pre">As you can see, passing a fully qualified closure (in terms of syntax)â€Šâ€”â€Šitâ€™s a bit much to take in. Plus, thatâ€™s a compounded problem if one canâ€™t use a trailing closure as the last argument.</p><p name="c92a" id="c92a" class="graf graf--p graf-after--p">So with @autoclosure, thatâ€™s essentially what we mean when we say that the closure <em class="markup--em markup--p-em">returns</em> <em class="markup--em markup--p-em">the actual value</em> thatâ€™s wrapped inside of it. You might even say the parameter became a closureâ€¦automatically, thus, @autoclosure ğŸ’¡!</p><p name="d55d" id="d55d" class="graf graf--p graf-after--p">This code is also inherently delayed. This is an added benefit if the actual closure might end up being an expensive task or it might bring about some unintended side effects. The code provided is never executed until the closure itâ€™s wrapped in is.</p><p name="8b1b" id="8b1b" class="graf graf--p graf-after--p">Another quick oneâ€Šâ€”â€Šwhere else might you have seen this in your recent iOS endeavors? How about assert()?</p><pre name="a5f8" id="a5f8" class="graf graf--pre graf-after--p">struct Programmer<br>{<br>    var isSenior:Bool<br>    var appsShipped:Int<br>}</pre><pre name="05ea" id="05ea" class="graf graf--pre graf-after--pre">let aSeniorDev = Programmer(isSenior: true, appsShipped: 13)<br>assert(aSeniorDev.isSenior, â€œThis dev isnâ€™t a senior!â€)</pre><p name="8bb4" id="8bb4" class="graf graf--p graf-after--pre">The first argument provided uses @autoclosure. If it werenâ€™t, again, the invocation might look something closer to this:</p><pre name="1897" id="1897" class="graf graf--pre graf-after--p">assert({ <br>    return aSeniorDev.isSenior <br>}, { <br>    return â€œThis dev isnâ€™t a senior!â€<br>})</pre><p name="8fa2" id="8fa2" class="graf graf--p graf-after--pre">With @autoclosure, the code is simply more digestible, and I would also argue that it also makes for a far more enjoyable reading experience.</p><p name="5cda" id="5cda" class="graf graf--p graf-after--p">And, if youâ€™re curious how assert()â€™s signature looks, itâ€™s something like this:</p><pre name="ab47" id="ab47" class="graf graf--pre graf-after--p">func assert(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</pre><p name="7628" id="7628" class="graf graf--p graf-after--pre">If youâ€™re thrown off by the other two parameters in the signature, we omitted them in the example because they have default values assigned to them. The more you know, right?</p><h4 name="d6d4" id="d6d4" class="graf graf--h4 graf-after--p">Before You Goâ€Šâ€”â€ŠUsing Multiple Attributes</h4><p name="0a77" id="0a77" class="graf graf--p graf-after--h4">While each attribute has benefits that help it stand on their own, itâ€™s also helpful to pair them together in certain scenarios.</p><p name="bc5c" id="bc5c" class="graf graf--p graf-after--p">For example, take the @escaping attribute. The @escaping attribute signifies that the passed in closure can outlast the function itâ€™s passed to:</p><pre name="351f" id="351f" class="graf graf--pre graf-after--p">//A property on a view controller<br>var onFakeCompletions:[()-&gt;()] = []</pre><pre name="0bf4" id="0bf4" class="graf graf--pre graf-after--pre">func fakeNetworkOp(_ completion:@escaping ()-&gt;())<br>{<br>    //Network stuff happens</pre><pre name="2093" id="2093" class="graf graf--pre graf-after--pre">    //The closure is appended to an external array outside of the   function&#39;s scope. This implies it could be invoked outside of the function - i.e., it could &quot;escape&quot; it<br>    onFakeCompletions.append(completion)<br>}</pre><p name="0210" id="0210" class="graf graf--p graf-after--pre">Considering this, we could use both @escaping <em class="markup--em markup--p-em">and</em> @autoclosure for the same parameter.</p><p name="7d09" id="7d09" class="graf graf--p graf-after--p">Letâ€™s imagine H.R. let us know that any developer who is both a Senior in title and has shipped at least three apps is due for a raise, <em class="markup--em markup--p-em">but</em> we also need to keep track of each evaluation for historical purposes:</p><pre name="5d69" id="5d69" class="graf graf--pre graf-after--p">class Programmer<br>{<br>    var previousPayRaiseEvaluations:[()-&gt;Bool] = []<br>    var isSenior:Bool = false<br>    var appsShipped:Int = 0</pre><pre name="b35f" id="b35f" class="graf graf--pre graf-after--pre">    func evaluatePayRaise(withAccolades raiseEvaluation:@escaping @autoclosure ()-&gt;Bool)<br>    {<br>        if raiseEvaluation()<br>        {<br>            //Give them a raise, and then save it to their records<br>            previousPayRaiseEvaluations.append(raiseEvaluation)<br>        }<br>    }<br>}</pre><pre name="47ca" id="47ca" class="graf graf--pre graf-after--pre">let aProgrammer = Programmer()<br>aProgrammer.isSenior = true<br>aProgrammer.appsShipped = 4</pre><pre name="77e3" id="77e3" class="graf graf--pre graf-after--pre">print(&quot;Past pay raise evaluations: \(aProgrammer.previousPayRaiseEvaluations.count)&quot;) //0</pre><pre name="b9ed" id="b9ed" class="graf graf--pre graf-after--pre">aProgrammer.evaluatePayRaise(withAccolades: aProgrammer.isSenior &amp;&amp; aProgrammer.appsShipped &gt; 3)</pre><pre name="5dfc" id="5dfc" class="graf graf--pre graf-after--pre">print(&quot;Past pay raise evaluations: \(aProgrammer.previousPayRaiseEvaluations.count)&quot;) //1</pre><p name="14d5" id="14d5" class="graf graf--p graf-after--pre">And just like that ğŸ’¯!</p><p name="7b8f" id="7b8f" class="graf graf--p graf-after--p">Thereâ€™s certainly nothing prohibiting you from â€œchainingâ€ attributes together, and when the situation calls for it, it works rather seamlessly.</p><h4 name="d224" id="d224" class="graf graf--h4 graf-after--p">Final Thoughts</h4><p name="e81c" id="e81c" class="graf graf--p graf-after--h4">Attributes have always been something Iâ€™ve been particularly curious about. I like the idea of doing some heavy lifting in a clear, concise and simple way in my codeâ€Šâ€”â€Šand thatâ€™s really what attributes are getting you.</p><p name="3d8b" id="3d8b" class="graf graf--p graf-after--p">Of course, there are the popular ones from the bunch worth knowing about, such as the ubiquitous @objc attribute in Swift + Objective-C projects. Certainly an argument could be made that attributes are almost more akin to a necessity rather than a nicety.</p><p name="7909" id="7909" class="graf graf--p graf-after--p">But, lest we forget, Swift does exist outside of iOS projects. And thatâ€™s an awesome thing, and my hope is that even though these attributes may not get the flashy headlines, perhaps they can help you when engineering your next bit of Swift code, iOS or otherwise.</p><p name="6b18" id="6b18" class="graf graf--p graf-after--p graf--trailing">Until next timeâ€Šâ€”â€Šthanks for @reading âœŒï¸.</p></div></div></section><section name="0c57" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><div name="e235" id="e235" class="graf graf--mixtapeEmbed graf--leading"><a href="https://www.twitter.com/jordanmorgan10" data-href="https://www.twitter.com/jordanmorgan10" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.twitter.com/jordanmorgan10" rel="nofollow"><strong class="markup--strong markup--mixtapeEmbed-strong">Jordan Morgan (@JordanMorgan10) | Twitter</strong><br><em class="markup--em markup--mixtapeEmbed-em">The latest Tweets from Jordan Morgan (@JordanMorgan10). iOS at @buffer. Live to code so I created @dibsoftwareâ€¦</em>www.twitter.com</a><a href="https://www.twitter.com/jordanmorgan10" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4a77553981d2c05a97a19011f58601f6" data-thumbnail-img-id="0*DIFbFZFZUL4Tmv4_." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*DIFbFZFZUL4Tmv4_.);"></a></div><pre name="d6b8" id="d6b8" class="graf graf--pre graf-after--mixtapeEmbed graf--trailing">If you enjoyed this week&#39;s post, please feel free to go ahead and NSRecommend(this, where: below);</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@JordanMorgan10" class="p-author h-card">Jordan Morgan</a> on <a href="https://medium.com/p/936f3426d5db"><time class="dt-published" datetime="2017-04-04T18:11:32.779Z">April 4, 2017</time></a>.</p><p><a href="https://medium.com/@JordanMorgan10/swift-attributes-936f3426d5db" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 23, 2018.</p></footer></article></body></html>