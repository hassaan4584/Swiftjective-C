{
    "version": "https://jsonfeed.org/version/1",
    "title": "Swiftjective-C",
    "description": "Swiftjective-C is a periodical over modern iOS software engineering. It houses tactful discussions over Swift, Objective-C and developing high quality apps while peering into various frameworks to see what makes them tick.\n",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "items": [
      {
            "id": "http://localhost:4000/2018/08/01/uigraphicsimagerenderer",
            "url": "http://localhost:4000/2018/08/01/uigraphicsimagerenderer.html",
            "title": "UIGraphicsImageRenderer",
            "content_html": "<p>The history of photography is rife with interesting stories of how the medium developed. Among them, digital photography is one of the more exciting bits of its history. It‚Äôs still quite a nascent craft, with its history tracing back to as recently as 1957 when the fine folks at the National Institute of Standards and Technology slapped a photo into computer memory.</p>\n\n<p>The translation from the analog to the digital was an inflection point. We‚Äôve experienced a similar shift on iOS starting with iOS 10, though many engineers have yet to discover or adopt the latest innovation for drawing images‚Ää‚Äî‚Ää<code class=\"highlighter-rouge\">UIGraphicsImageRenderer</code>.</p>\n\n<h3 id=\"setting-the-cgcontext\">Setting the (CG)Context</h3>\n<p>Core Graphics, based on the Quartz drawing engine, has provided iOS developers with lightweight 2D rendering capabilities since iOS 2. Its utility knows almost no bounds, as image masking, PDF document creation, parsing, and other similar functions are baked right in making it a no nonsense choice for any sort of drawing task.</p>\n\n<p>For that and many other reasons, if one hits the Googles on how to create an image from something on screen they‚Äôll likely end up with something like this:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">drawSize</span> <span class=\"o\">=</span> <span class=\"kt\">CGSize</span><span class=\"p\">(</span><span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"mi\">20</span><span class=\"p\">)</span>\n\n<span class=\"kt\">UIGraphicsBeginImageContext</span><span class=\"p\">(</span><span class=\"n\">drawSize</span><span class=\"p\">)</span>  \n<span class=\"k\">let</span> <span class=\"nv\">ctx</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsGetCurrentContext</span><span class=\"p\">()</span><span class=\"o\">!</span>\n\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">setFillColor</span><span class=\"p\">(</span><span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">red</span><span class=\"o\">.</span><span class=\"n\">cgColor</span><span class=\"p\">)</span>  \n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">drawSize</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">drawSize</span><span class=\"o\">.</span><span class=\"n\">height</span><span class=\"p\">))</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">img</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>And it works, so we move on. Though, there are several valid reasons to pump the breaks:</p>\n\n<ul>\n  <li>UIGraphicsBegin/EndImageContext are sRGB only (sorry p3 color gamut).</li>\n  <li>It was before the age of blocks, which are common throughout Foundation, UIKit and virtually every framework on iOS.</li>\n  <li>Extensibility is possible, though sometimes a non trivial task.</li>\n</ul>\n\n<p>Given its age, it‚Äôs not a shocker to say Core Graphics provides an API that‚Äôs less than ideal too many of today‚Äôs standards. Though Swift‚Äôs syntactical sugar prowess has softened the call sites to Core Graphics code over many projects, it still is what it is‚Ää‚Äî‚Ääa C based API built for simpler times.</p>\n\n<p>In contrast, <code class=\"highlighter-rouge\">UIGraphicsImageRenderer</code> is built for tomorrow in mind:</p>\n\n<ul>\n  <li>It‚Äôs automagically fully color managed. For example, on the beautiful 9.7 inch iPad pro you‚Äôll get a wide color context.</li>\n  <li>It‚Äôs a first class object.</li>\n  <li>It manages its context lifetime, unlocking some memory optimizations on the house from Cupertino &amp; Friends¬©.</li>\n  <li>The former implicitly means that it caches its context, meaning reuse is an efficient operation as opposed to using new renderers.</li>\n</ul>\n\n<h3 id=\"gaining-more-cgcontext\">Gaining More (CG)Context</h3>\n\n<p>Initializing and keeping a reference to a renderer is a solid start:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">renderer</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsImageRenderer</span><span class=\"p\">(</span><span class=\"nv\">size</span><span class=\"p\">:</span> <span class=\"kt\">CGSize</span><span class=\"p\">(</span><span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"mi\">20</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p>From there, the relevant parallel from the old way of doing things to the preferred, Apple approved way would be image renderer‚Äôs closure based functions for creating an image:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">image</span><span class=\"p\">(</span><span class=\"nv\">actions</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"kt\">UIGraphicsImageRendererContext</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">UIImage</span>\n</code></pre></div></div>\n\n<p>To compare apples to image renderers, one could create the same image as mentioned above from the legacy Core Graphics method by doing this:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">img</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">image</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span> <span class=\"k\">in</span>  \n    <span class=\"k\">let</span> <span class=\"nv\">size</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"o\">.</span><span class=\"n\">size</span>  \n    <span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">red</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">height</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>The hard work of what‚Äôs happening here has always been abstracted away by Core Graphics since day one, but now it‚Äôs more honed in to the point where we simply spit out some drawing instructions within a block.</p>\n\n<p>The renderer also exposes convenient access to getting a hold of <code class=\"highlighter-rouge\">NSData</code> of resulting images as well:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">actions</span><span class=\"p\">:(</span><span class=\"kt\">UIGraphicsImageRendererContext</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span> <span class=\"k\">in</span>  \n<span class=\"k\">let</span> <span class=\"nv\">size</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"o\">.</span><span class=\"n\">size</span>  \n<span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">blue</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">width</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>  \n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">imageJPEGData</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"nf\">jpegData</span><span class=\"p\">(</span><span class=\"nv\">withCompressionQuality</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">actions</span><span class=\"p\">:</span> <span class=\"n\">actions</span><span class=\"p\">)</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">imagePNGData</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"nf\">pngData</span><span class=\"p\">(</span><span class=\"nv\">actions</span><span class=\"p\">:</span> <span class=\"n\">actions</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>In each code sample, the typealiased <code class=\"highlighter-rouge\">DrawingActions</code> closure returns to us an instance of <code class=\"highlighter-rouge\">UIGraphicsImageRendererContext</code>. Using it we gain access high-level drawing functions. Though Apple clearly states ‚Äúhigher level‚Äù drawing functions, don‚Äôt think of it as a crutch. There is support for most drawing tasks, such as utilizing blend modes by leveraging <code class=\"highlighter-rouge\">CGBlendValue</code>:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">image</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">image</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span> <span class=\"k\">in</span>  \n<span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">blue</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"mi\">140</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"mi\">140</span><span class=\"p\">))</span>\n\n<span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">yellow</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"mi\">140</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"mi\">140</span><span class=\"p\">),</span> <span class=\"nv\">blendMode</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">luminosity</span><span class=\"p\">)</span>  \n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>That said, you may be left missing the drawing functionality you might‚Äôve thought left behind from the traditional context.</p>\n\n<p>For example, filling in an ellipses still requires a R.O.C.G.C. (regular old Core Graphics Context, obviously). To fill out the drawing functionality (pun somewhat intended), an image renderer context has one available.</p>\n\n<p>Take note of the last two lines, where the <code class=\"highlighter-rouge\">cgContext</code> allows us to fill out the circle:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">img</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">image</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span> <span class=\"k\">in</span>  \n    <span class=\"k\">let</span> <span class=\"nv\">size</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"o\">.</span><span class=\"n\">size</span>\n\n    <span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">darkGray</span><span class=\"o\">.</span><span class=\"nf\">setStroke</span><span class=\"p\">()</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">stroke</span><span class=\"p\">(</span><span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"p\">)</span>\n\n    <span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">blue</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">fill</span><span class=\"p\">(</span><span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">width</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n    <span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">yellow</span><span class=\"o\">.</span><span class=\"nf\">setFill</span><span class=\"p\">()</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">cgContext</span><span class=\"o\">.</span><span class=\"nf\">fillEllipse</span><span class=\"p\">(</span><span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">51</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">51</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">size</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">))</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">cgContext</span><span class=\"o\">.</span><span class=\"nf\">rotate</span><span class=\"p\">(</span><span class=\"nv\">by</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">)</span>  \n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"giving-a-renderer-more-cgcontext\">Giving a Renderer More (CG)Context</h3>\n<p>I really need to stop with the (CG)Context bit, but I feel too invested at this point so please just excuse me ü§†.</p>\n\n<p>You have noticed that a graphics renderer will also accept a <code class=\"highlighter-rouge\">UIGraphicsImageRendererFormat</code>object into two of its four available initializers:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"nv\">size</span><span class=\"p\">:</span> <span class=\"kt\">CGSize</span><span class=\"p\">,</span> <span class=\"nv\">format</span><span class=\"p\">:</span> <span class=\"kt\">UIGraphicsImageRendererFormat</span><span class=\"p\">)</span>  \n<span class=\"kd\">public</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"nv\">bounds</span><span class=\"p\">:</span> <span class=\"kt\">CGRect</span><span class=\"p\">,</span> <span class=\"nv\">format</span><span class=\"p\">:</span> <span class=\"kt\">UIGraphicsImageRendererFormat</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>This rendering format has a few options to aid in further specifying the intent of your resulting drawing operations. It also has a useful <code class=\"highlighter-rouge\">bounds </code>property we‚Äôve been using in the previous code samples that‚Äôs derived from its associated graphics context. Using this formatter one can tweak opaque or scale preferences, among other things.</p>\n\n<p>For example, <code class=\"highlighter-rouge\">CALayer</code> and its A8 backing store format was introduced in iOS 12 and provides developers with free memory optimizations. If you‚Äôre certain, for example, that you‚Äôre drawing wide color content <em>using</em> sRGB colors, you can have the renderer optimize for that since the backing store would otherwise be larger to accommodate a larger color range rather than just 0 to 1:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// iOS 10/11</span>\n<span class=\"k\">let</span> <span class=\"nv\">format</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsImageRendererFormat</span><span class=\"p\">()</span>  \n<span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">prefersExtendedRange</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n\n<span class=\"c1\">// iOS 12</span>\n<span class=\"k\">let</span> <span class=\"nv\">format</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsImageRendererFormat</span><span class=\"p\">()</span>  \n<span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">preferredRange</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"n\">standard</span> <span class=\"c1\">// Turn off iOS 12 optimization</span>\n</code></pre></div></div>\n\n<p>Many of these decisions will likely be tied to the current trait collection, so it stands to reason that the renderer format can also be fetched on a per trait collection basis as well.</p>\n\n<p>No need to mince in my own words here, Apple‚Äôs documentation explains this very well:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// Returns a format optimized for the specified trait collection, taking into account properties such as displayScale and displayGamut.</span>\n<span class=\"c1\">// Traits that are not specified will be ignored, with their corresponding format properties defaulting to the values in preferredFormat.  </span>\n<span class=\"kd\">public</span> <span class=\"kd\">convenience</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"k\">for</span> <span class=\"nv\">traitCollection</span><span class=\"p\">:</span> <span class=\"kt\">UITraitCollection</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>No worries if you opt to forgo any of this, as UIKit provides sensible default values for you should you not provide explicit ones. As such, if you do nothing, UIKit gives you the resulting format from its factory method, <code class=\"highlighter-rouge\">defaultFormat</code>‚Ää‚Äî‚Ääwhich provides a format configured for the highest fidelity possible as supported by the device it‚Äôs executed on.</p>\n\n<p>Take care to make this choice upfront, however. If you want to configure things, do it at your renderer‚Äôs initialization point as the formatter itself holistically represents immutable configurations that it will always use during drawing operations.</p>\n\n<p>All of this hopefully should remind you how extensible and flexible an image renderer can be. For example, hanging a quick extension off of any view to create a circle avatar would be painless and performant (as performant as using <code class=\"highlighter-rouge\">cornerRadius</code> can really be, that is) since one could reuse the same renderer and its context:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">rendererKey</span><span class=\"p\">:</span> <span class=\"kt\">UInt8</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">UIView</span> <span class=\"p\">{</span>\n<span class=\"k\">var</span> <span class=\"nv\">renderer</span><span class=\"p\">:</span> <span class=\"kt\">UIGraphicsImageRenderer</span><span class=\"o\">!</span> <span class=\"p\">{</span>  \n    <span class=\"k\">get</span> <span class=\"p\">{</span>  \n        <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">rendererInstance</span> <span class=\"o\">=</span> <span class=\"nf\">objc_getAssociatedObject</span><span class=\"p\">(</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">rendererKey</span><span class=\"p\">)</span> <span class=\"k\">as?</span> <span class=\"kt\">UIGraphicsImageRenderer</span> <span class=\"k\">else</span> <span class=\"p\">{</span>  \n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">renderer</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsImageRenderer</span><span class=\"p\">(</span><span class=\"nv\">bounds</span><span class=\"p\">:</span> <span class=\"n\">bounds</span><span class=\"p\">)</span>  \n            <span class=\"k\">return</span> <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">renderer</span>  \n        <span class=\"p\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">rendererInstance</span>\n    <span class=\"p\">}</span>  \n    <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"n\">newValue</span><span class=\"p\">)</span> <span class=\"p\">{</span>  \n        <span class=\"nf\">objc_setAssociatedObject</span><span class=\"p\">(</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">rendererKey</span><span class=\"p\">,</span> <span class=\"n\">newValue</span><span class=\"p\">,</span> <span class=\"n\">objc_AssociationPolicy</span><span class=\"o\">.</span><span class=\"kt\">OBJC_ASSOCIATION_RETAIN</span><span class=\"p\">)</span>  \n    <span class=\"p\">}</span>  \n<span class=\"p\">}</span>\n\n    <span class=\"kd\">func</span> <span class=\"nf\">circleImageView</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">UIImageView</span> <span class=\"p\">{</span>  \n        <span class=\"k\">let</span> <span class=\"nv\">img</span><span class=\"p\">:</span><span class=\"kt\">UIImage</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">image</span> <span class=\"p\">{</span> <span class=\"n\">ctx</span> <span class=\"k\">in</span>  \n            <span class=\"n\">layer</span><span class=\"o\">.</span><span class=\"nf\">render</span><span class=\"p\">(</span><span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">cgContext</span><span class=\"p\">)</span>  \n        <span class=\"p\">}</span>\n\n        <span class=\"k\">let</span> <span class=\"nv\">imageView</span><span class=\"p\">:</span><span class=\"kt\">UIImageView</span> <span class=\"o\">=</span> <span class=\"kt\">UIImageView</span><span class=\"p\">(</span><span class=\"nv\">image</span><span class=\"p\">:</span> <span class=\"n\">img</span><span class=\"p\">)</span>  \n        <span class=\"n\">imageView</span><span class=\"o\">.</span><span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span>  \n        <span class=\"n\">imageView</span><span class=\"o\">.</span><span class=\"n\">clipsToBounds</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>  \n        <span class=\"n\">imageView</span><span class=\"o\">.</span><span class=\"n\">layer</span><span class=\"o\">.</span><span class=\"n\">cornerRadius</span> <span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">rounded</span><span class=\"p\">()</span>  \n        <span class=\"k\">return</span> <span class=\"n\">imageView</span>  \n    <span class=\"p\">}</span>  \n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Generate a circle image and image view of any view instance  </span>\n<span class=\"k\">let</span> <span class=\"nv\">anImageView</span> <span class=\"o\">=</span> <span class=\"n\">myExistingView</span><span class=\"o\">.</span><span class=\"nf\">circleImageView</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<h3 id=\"pdfs-ftw\">PDFs FTW</h3>\n<p>A quick sidebar to mention that the PDF variant of the abstract <code class=\"highlighter-rouge\">UIGraphicsRenderer</code> class is very similar to its image rendering sibling. In fact, their method declarations are almost interchangeable, save <code class=\"highlighter-rouge\">UIImage</code> vs <code class=\"highlighter-rouge\">Data</code>:</p>\n\n<div class=\"language-swift highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"k\">let</span> <span class=\"nv\">renderer</span> <span class=\"o\">=</span> <span class=\"kt\">UIGraphicsPDFRenderer</span><span class=\"p\">(</span><span class=\"nv\">bounds</span><span class=\"p\">:</span> <span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"p\">)</span>  \n    <span class=\"k\">let</span> <span class=\"nv\">pdf</span> <span class=\"o\">=</span> <span class=\"n\">renderer</span><span class=\"o\">.</span><span class=\"n\">pdfData</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span> <span class=\"k\">in</span>  \n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"nf\">beginPage</span><span class=\"p\">()</span>\n    \n    \n        <span class=\"k\">let</span> <span class=\"nv\">header</span> <span class=\"o\">=</span> <span class=\"s\">\"Welcome to TTIDG!\"</span> <span class=\"k\">as</span> <span class=\"kt\">NSString</span>  \n    <span class=\"k\">let</span> <span class=\"nv\">attributes</span> <span class=\"o\">=</span> <span class=\"p\">[</span>  \n    <span class=\"kt\">NSAttributedStringKey</span><span class=\"o\">.</span><span class=\"nv\">font</span> <span class=\"p\">:</span> <span class=\"kt\">UIFont</span><span class=\"o\">.</span><span class=\"nf\">preferredFont</span><span class=\"p\">(</span><span class=\"nv\">forTextStyle</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">),</span>  \n    <span class=\"kt\">NSAttributedStringKey</span><span class=\"o\">.</span><span class=\"nv\">foregroundColor</span> <span class=\"p\">:</span> <span class=\"kt\">UIColor</span><span class=\"o\">.</span><span class=\"n\">blue</span>  \n    <span class=\"p\">]</span>\n    \n    \n        <span class=\"n\">header</span><span class=\"o\">.</span><span class=\"nf\">draw</span><span class=\"p\">(</span><span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"kt\">CGRect</span><span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">width</span><span class=\"p\">:</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">pdfContextBounds</span><span class=\"o\">.</span><span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"nv\">height</span><span class=\"p\">:</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">pdfContextBounds</span><span class=\"o\">.</span><span class=\"n\">height</span><span class=\"p\">),</span> <span class=\"nv\">withAttributes</span><span class=\"p\">:</span> <span class=\"n\">attributes</span><span class=\"p\">)</span>  \n    <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"wrapping-up\">Wrapping Up</h3>\n<p>Replacing the code that kinda just works with the code that‚Äôs more recent and supports more relevant formats is typically not high on the proverbial list.</p>\n\n<p>Maybe it should be, as is the case with <code class=\"highlighter-rouge\">UIGraphicsImageRenderer</code>. You likely won‚Äôt have to twist many arms to persuade iOS engineers to make the switch, ‚ÄúNo ‚úã‚Ää‚Äî‚ÄäI don‚Äôt want block based, automatically color managed, extensible drawing code that already manages its context lifetime‚Ää‚Äî‚Ääthat‚Äôs awful‚Äù said‚Ä¶..nobody?</p>\n\n<p>Until next time, may your drawing exploits with <code class=\"highlighter-rouge\">UIGraphicsImageRenderer</code> be many and productive üì∏.</p>",
            "summary": "The history of photography is rife with interesting stories of how the medium developed. Among them, digital photography is one of the more exciting bits of its history. It‚Äôs still quite a nascent craft, with its history tracing back to as recently as 1957 when the fine folks at the National Institute of Standards and Technology slapped a photo into computer memory.",
            "image": "http://localhost:4000/assets/images/logo.png",
            "date_published": "2018-08-01T00:00:00-05:00",
            "date_modified": "2018-08-01T00:00:00-05:00",
            "author": {
              "name": "Jordan Morgan"},
            "tags": ["UIKit"]}]
}